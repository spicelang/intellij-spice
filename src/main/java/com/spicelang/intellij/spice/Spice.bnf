{
  parserClass="com.spicelang.intellij.spice.SpiceParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Spice"
  psiImplClassSuffix="Impl"
  psiPackage="com.spicelang.intellij.spice.psi"
  psiImplPackage="com.spicelang.intellij.spice.psi.impl"

  elementTypeHolderClass="com.spicelang.intellij.spice.psi.SpiceTypes"
  elementTypeClass="com.spicelang.intellij.spice.psi.SpiceElementType"
  tokenTypeClass="com.spicelang.intellij.spice.psi.SpiceTokenType"
}

spiceFile ::= (mainFunctionDef | functionDef | procedureDef | structDef | globalVarDef | importStmt | extDecl | lineCom | blockCom)*
lineCom ::= LINE_COMMENT
blockCom ::= BLOCK_COMMENT

// Control structures
mainFunctionDef ::= F LESS TYPE_INT GREATER MAIN LPAREN paramLstDef? RPAREN LBRACE stmtLst RBRACE
functionDef ::= F LESS dataType GREATER (IDENTIFIER DOT)? IDENTIFIER LPAREN paramLstDef? RPAREN LBRACE stmtLst RBRACE
procedureDef ::= P (IDENTIFIER DOT)? IDENTIFIER LPAREN paramLstDef? RPAREN LBRACE stmtLst RBRACE
extDecl ::= EXT (LESS dataType GREATER)? IDENTIFIER LPAREN typeLst? RPAREN DLL? SEMICOLON
structDef ::= TYPE IDENTIFIER STRUCT LBRACE fieldLst RBRACE
globalVarDef ::= CONST? dataType IDENTIFIER (ASSIGN_OP value)? SEMICOLON
forLoop ::= FOR assignExpr SEMICOLON assignExpr SEMICOLON assignExpr LBRACE stmtLst RBRACE
foreachLoop ::= FOREACH (foreachHead | LPAREN foreachHead RPAREN) LBRACE stmtLst RBRACE
foreachHead ::= ((declStmt | assignExpr) COMMA)? declStmt COLON assignExpr
whileLoop ::= WHILE assignExpr LBRACE stmtLst RBRACE
ifStmt ::= IF assignExpr LBRACE stmtLst RBRACE elseStmt?
elseStmt ::= ELSE ifStmt | ELSE LBRACE stmtLst RBRACE

// Statements, declarations, definitions and lists
stmtLst ::= (stmt | forLoop | foreachLoop | whileLoop | ifStmt)*
fieldLst ::= declStmt*
typeLst ::= dataType (COMMA dataType)* ELLIPSIS?
paramLstDef ::= (declStmt | assignExpr) (COMMA (declStmt | assignExpr))*
paramLst ::= assignExpr (COMMA assignExpr)*
stmt ::= (assignExpr | declStmt | newStmt | arrayInitStmt | idenValue | builtinCall | returnStmt | breakStmt | continueStmt) SEMICOLON
declStmt ::= CONST? dataType IDENTIFIER
functionCall ::= IDENTIFIER LPAREN paramLst? RPAREN
newStmt ::= CONST? dataType IDENTIFIER ASSIGN_OP NEW IDENTIFIER (DOT IDENTIFIER)* LBRACE paramLst? RBRACE
arrayInitStmt ::= CONST? dataType IDENTIFIER (ASSIGN_OP LBRACE paramLst? RBRACE)?
importStmt ::= IMPORT STRING AS IDENTIFIER SEMICOLON
returnStmt ::= RETURN assignExpr?
breakStmt ::= BREAK INTEGER?
continueStmt ::= CONTINUE INTEGER?

// Builtin functions
builtinCall ::= printfCall | sizeOfCall
printfCall ::= PRINTF LPAREN STRING (COMMA assignExpr)* RPAREN
sizeOfCall ::= SIZEOF LPAREN assignExpr RPAREN

// Expression loop
assignExpr ::= ((declStmt | idenValue) (ASSIGN_OP | PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL | SHL_EQUAL | SHR_EQUAL))? ternaryExpr
ternaryExpr ::= logicalOrExpr (QUESTION_MARK logicalOrExpr COLON logicalOrExpr)?
logicalOrExpr ::= logicalAndExpr (LOGICAL_OR logicalAndExpr)*
logicalAndExpr ::= bitwiseOrExpr (LOGICAL_AND bitwiseOrExpr)*
bitwiseOrExpr ::= bitwiseAndExpr (BITWISE_OR bitwiseAndExpr)*
bitwiseAndExpr ::= equalityExpr (BITWISE_AND equalityExpr)*
equalityExpr ::= relationalExpr ((EQUAL | NOT_EQUAL) relationalExpr)?
relationalExpr ::= shiftExpr ((LESS | GREATER | LESS_EQUAL | GREATER_EQUAL) shiftExpr)?
shiftExpr ::= additiveExpr ((SHL | SHR) additiveExpr)?
additiveExpr ::= multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
multiplicativeExpr ::= prefixUnaryExpr ((MUL | DIV | REM) prefixUnaryExpr)*
prefixUnaryExpr ::= (NOT | PLUS_PLUS | MINUS_MINUS)? postfixUnaryExpr
postfixUnaryExpr ::= castExpr (PLUS_PLUS | MINUS_MINUS)?
castExpr ::= (LPAREN dataType RPAREN)? atomicExpr
atomicExpr ::= value | idenValue | builtinCall | LPAREN assignExpr RPAREN

// Values and types
idenValue ::= (BITWISE_AND | MUL)* (functionCall | IDENTIFIER) (LBRACKET assignExpr RBRACKET)? (DOT (functionCall | IDENTIFIER) (LBRACKET assignExpr RBRACKET)?)*
value ::= DOUBLE | INTEGER | CHAR | STRING | TRUE | FALSE | NIL LESS dataType GREATER;
dataType ::= (TYPE_DOUBLE | TYPE_INT | TYPE_SHORT | TYPE_LONG | TYPE_BYTE | TYPE_CHAR | TYPE_STRING | TYPE_BOOL | TYPE_DYN | IDENTIFIER (DOT IDENTIFIER)*) (MUL | LBRACKET INTEGER? RBRACKET)*