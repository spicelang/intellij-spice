/*
 * Copyright (c) 2022-2023 ChilliBits. All rights reserved.
 */

{
  parserClass="com.spicelang.intellij.spice.SpiceParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Spice"
  psiImplClassSuffix="Impl"
  psiPackage="com.spicelang.intellij.spice.psi"
  psiImplPackage="com.spicelang.intellij.spice.psi.impl"

  elementTypeHolderClass="com.spicelang.intellij.spice.psi.SpiceTypes"
  elementTypeClass="com.spicelang.intellij.spice.psi.SpiceElementType"
  tokenTypeClass="com.spicelang.intellij.spice.psi.SpiceTokenType"

  psiImplUtilClass="com.spicelang.intellij.spice.psi.impl.SpicePsiImplUtil"
}

// Top level definitions and declarations
spiceFile ::= (mainFunctionDef | functionDef | procedureDef | structDef | interfaceDef | enumDef | genericTypeDef | aliasDef | globalVarDef | importStmt | extDecl | docCom | lineCom | blockCom)*
docCom ::= DOC_COMMENT
lineCom ::= LINE_COMMENT
blockCom ::= BLOCK_COMMENT
mainFunctionDef ::= F LESS TYPE_INT GREATER MAIN LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
functionDef ::= specifierLst? F LESS dataType GREATER functionName (LESS typeLst GREATER)? LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
procedureDef ::= specifierLst? P functionName (LESS typeLst GREATER)? LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
functionName ::= (identifierExpr DOT)? identifierExpr | OPERATOR overloadableOp;
structDef ::= specifierLst? TYPE IDENTIFIER (LESS typeLst GREATER)? STRUCT (COLON typeLst)? LBRACE field* RBRACE
interfaceDef ::= specifierLst? TYPE IDENTIFIER (LESS typeLst GREATER)? INTERFACE LBRACE signature+ RBRACE
enumDef ::= specifierLst? TYPE IDENTIFIER ENUM LBRACE enumItemLst RBRACE
genericTypeDef ::= TYPE IDENTIFIER typeAltsLst SEMICOLON
aliasDef ::= specifierLst? TYPE IDENTIFIER ALIAS dataType SEMICOLON
globalVarDef ::= dataType identifierExpr (ASSIGN MINUS? value)? SEMICOLON
extDecl ::= EXT (F LESS dataType GREATER | P) identifierExpr LPAREN (typeLst ELLIPSIS?)? RPAREN DLL? SEMICOLON

// Control structures
threadDef ::= THREAD LBRACE stmtLst RBRACE
unsafeBlockDef ::= UNSAFE LBRACE stmtLst RBRACE
forLoop ::= FOR (forHead | LPAREN forHead RPAREN) LBRACE stmtLst RBRACE
forHead ::= declStmt SEMICOLON assignExpr SEMICOLON assignExpr
foreachLoop ::= FOREACH (foreachHead | LPAREN foreachHead RPAREN) LBRACE stmtLst RBRACE
foreachHead ::= (declStmt COMMA)? declStmt COLON assignExpr
whileLoop ::= WHILE assignExpr LBRACE stmtLst RBRACE
doWhileLoop ::= DO LBRACE stmtLst RBRACE WHILE assignExpr SEMICOLON
ifStmt ::= IF assignExpr LBRACE stmtLst RBRACE elseStmt?
elseStmt ::= ELSE ifStmt | ELSE LBRACE stmtLst RBRACE
anonymousBlockStmt ::= LBRACE stmtLst RBRACE;

// Statements, declarations, definitions and lists
stmtLst ::= (stmt | forLoop | foreachLoop | whileLoop | doWhileLoop | ifStmt | assertStmt | threadDef | unsafeBlockDef | anonymousBlockStmt)*
typeLst ::= dataType (COMMA dataType)*
typeAltsLst ::= dataType (BITWISE_OR dataType)*;
paramLst ::= declStmt (COMMA declStmt)*
argLst ::= assignExpr (COMMA assignExpr)*
enumItemLst ::= enumItem (COMMA enumItem)*
enumItem ::= IDENTIFIER (ASSIGN INT_LIT)?
field ::= dataType IDENTIFIER
signature ::= specifierLst? (F LESS dataType GREATER | P) IDENTIFIER (LESS typeLst GREATER)? LPAREN typeLst? RPAREN SEMICOLON
stmt ::= (declStmt | assignExpr | returnStmt | breakStmt | continueStmt) SEMICOLON
declStmt ::= dataType identifierExpr (ASSIGN assignExpr)?
specifierLst ::= specifier+
specifier ::= CONST | SIGNED | UNSIGNED | INLINE | PUBLIC | HEAP
importStmt ::= IMPORT STRING_LIT (AS identifierExpr)? SEMICOLON
returnStmt ::= RETURN assignExpr?
breakStmt ::= BREAK INT_LIT?
continueStmt ::= CONTINUE INT_LIT?
assertStmt ::= ASSERT assignExpr SEMICOLON

// Builtin functions
builtinCall ::= printfCall | sizeOfCall | lenCall | tidCall | joinCall
printfCall ::= PRINTF LPAREN STRING_LIT (COMMA assignExpr)* RPAREN
sizeOfCall ::= SIZEOF LPAREN (assignExpr | TYPE dataType) RPAREN
lenCall ::= LEN LPAREN assignExpr RPAREN
tidCall ::= TID LPAREN RPAREN
joinCall ::= JOIN LPAREN assignExpr (COMMA assignExpr)* RPAREN;

// Expression loop
assignExpr ::= prefixUnaryExpr assignOp assignExpr | ternaryExpr | threadDef
ternaryExpr ::= logicalOrExpr (QUESTION_MARK logicalOrExpr? COLON logicalOrExpr)?
logicalOrExpr ::= logicalAndExpr (LOGICAL_OR logicalAndExpr)*
logicalAndExpr ::= bitwiseOrExpr (LOGICAL_AND bitwiseOrExpr)*
bitwiseOrExpr ::= bitwiseXorExpr (BITWISE_OR bitwiseXorExpr)*
bitwiseXorExpr ::= bitwiseAndExpr (BITWISE_XOR bitwiseAndExpr)*
bitwiseAndExpr ::= equalityExpr (BITWISE_AND equalityExpr)*
equalityExpr ::= relationalExpr ((EQUAL | NOT_EQUAL) relationalExpr)?
relationalExpr ::= shiftExpr ((LESS | GREATER | LESS_EQUAL | GREATER_EQUAL) shiftExpr)?
shiftExpr ::= additiveExpr ((LESS LESS | GREATER GREATER) additiveExpr)?
additiveExpr ::= multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
multiplicativeExpr ::= castExpr ((MUL | DIV | REM) castExpr)*
castExpr ::= LPAREN dataType RPAREN prefixUnaryExpr | prefixUnaryExpr
prefixUnaryExpr ::= prefixUnaryOp* postfixUnaryExpr
postfixUnaryExpr ::= atomicExpr (LBRACKET assignExpr RBRACKET | DOT postfixUnaryExpr | PLUS_PLUS | MINUS_MINUS | SCOPE_ACCESS postfixUnaryExpr)*
atomicExpr ::= value | identifierExpr | builtinCall | LPAREN assignExpr RPAREN {methods=[getIdentifier]}

// Values
value ::= constant | functionCall | arrayInitialization | structInstantiation | NIL LESS dataType GREATER
constant ::= DOUBLE_LIT | INT_LIT | SHORT_LIT | LONG_LIT | CHAR_LIT | STRING_LIT | TRUE | FALSE
functionCall ::= identifierExpr (DOT identifierExpr)* (LESS typeLst GREATER)? LPAREN argLst? RPAREN
arrayInitialization ::= LBRACE argLst? RBRACE
structInstantiation ::= identifierExpr (SCOPE_ACCESS identifierExpr)* (LESS typeLst GREATER)? LBRACE argLst? RBRACE

// Types
dataType ::= specifierLst? baseDataType (MUL | BITWISE_AND | LBRACKET (INT_LIT | IDENTIFIER)? RBRACKET)*
baseDataType ::= TYPE_DOUBLE | TYPE_INT | TYPE_SHORT | TYPE_LONG | TYPE_BYTE | TYPE_CHAR | TYPE_STRING | TYPE_BOOL | TYPE_DYN | customDataType
customDataType ::= identifierExpr (SCOPE_ACCESS identifierExpr)* (LESS typeLst GREATER)?

// Shorthands
assignOp ::= ASSIGN | PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL | REM_EQUAL | SHL_EQUAL | SHR_EQUAL | AND_EQUAL | OR_EQUAL | XOR_EQUAL
prefixUnaryOp ::= MINUS | PLUS_PLUS | MINUS_MINUS | NOT | BITWISE_NOT | MUL | BITWISE_AND | LOGICAL_AND // Here, '&&' means the same as two times '&'
overloadableOp ::= PLUS | MINUS | MUL | DIV | EQUAL | NOT_EQUAL | PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL;

identifierExpr ::= IDENTIFIER {
    mixin="com.spicelang.intellij.spice.psi.impl.SpiceNamedElementImpl"
    implements="com.spicelang.intellij.spice.psi.SpiceNamedElement"
    methods=[getIdentifier getName setName getNameIdentifier]
}