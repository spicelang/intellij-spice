/*
 * Copyright (c) 2022-2023 ChilliBits. All rights reserved.
 */

{
  parserClass="com.spicelang.intellij.spice.SpiceParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Spice"
  psiImplClassSuffix="Impl"
  psiPackage="com.spicelang.intellij.spice.psi"
  psiImplPackage="com.spicelang.intellij.spice.psi.impl"

  elementTypeHolderClass="com.spicelang.intellij.spice.psi.SpiceTypes"
  elementTypeClass="com.spicelang.intellij.spice.psi.SpiceElementType"
  tokenTypeClass="com.spicelang.intellij.spice.psi.SpiceTokenType"

  psiImplUtilClass="com.spicelang.intellij.spice.psi.impl.SpicePsiImplUtil"
}

// Top level definitions and declarations
spiceFile ::= (mainFunctionDef | functionDef | procedureDef | structDef | interfaceDef | enumDef | genericTypeDef | aliasDef | globalVarDef | importStmt | extDecl | modAttr | docCom | lineCom | blockCom)*
docCom ::= DOC_COMMENT
lineCom ::= LINE_COMMENT
blockCom ::= BLOCK_COMMENT
mainFunctionDef ::= fctAttr? F LESS TYPE_INT GREATER MAIN LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
functionDef ::= fctAttr? specifierLst? F LESS dataType GREATER functionName (LESS typeLst GREATER)? LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
procedureDef ::= fctAttr? specifierLst? P functionName (LESS typeLst GREATER)? LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
functionName ::= (TYPE_IDENTIFIER DOT)? IDENTIFIER | OPERATOR overloadableOp;
structDef ::= specifierLst? TYPE TYPE_IDENTIFIER (LESS typeLst GREATER)? STRUCT (COLON typeLst)? LBRACE field* RBRACE
interfaceDef ::= specifierLst? TYPE TYPE_IDENTIFIER (LESS typeLst GREATER)? INTERFACE LBRACE signature+ RBRACE
enumDef ::= specifierLst? TYPE TYPE_IDENTIFIER ENUM LBRACE enumItemLst RBRACE
genericTypeDef ::= TYPE TYPE_IDENTIFIER typeAltsLst SEMICOLON
aliasDef ::= specifierLst? TYPE TYPE_IDENTIFIER ALIAS dataType SEMICOLON
globalVarDef ::= dataType TYPE_IDENTIFIER (ASSIGN MINUS? value)? SEMICOLON
extDecl ::= fctAttr? EXT (F LESS dataType GREATER | P) IDENTIFIER LPAREN (typeLst ELLIPSIS?)? RPAREN SEMICOLON

// Control structures
unsafeBlockDef ::= UNSAFE LBRACE stmtLst RBRACE
forLoop ::= FOR (forHead | LPAREN forHead RPAREN) LBRACE stmtLst RBRACE
forHead ::= declStmt SEMICOLON assignExpr SEMICOLON assignExpr
foreachLoop ::= FOREACH (foreachHead | LPAREN foreachHead RPAREN) LBRACE stmtLst RBRACE
foreachHead ::= (declStmt COMMA)? declStmt COLON assignExpr
whileLoop ::= WHILE assignExpr LBRACE stmtLst RBRACE
doWhileLoop ::= DO LBRACE stmtLst RBRACE WHILE assignExpr SEMICOLON
ifStmt ::= IF assignExpr LBRACE stmtLst RBRACE elseStmt?
elseStmt ::= ELSE ifStmt | ELSE LBRACE stmtLst RBRACE
anonymousBlockStmt ::= LBRACE stmtLst RBRACE;

// Statements, declarations, definitions and lists
stmtLst ::= (stmt | forLoop | foreachLoop | whileLoop | doWhileLoop | ifStmt | assertStmt | unsafeBlockDef | anonymousBlockStmt)*
typeLst ::= dataType (COMMA dataType)*
typeAltsLst ::= dataType (BITWISE_OR dataType)*;
paramLst ::= declStmt (COMMA declStmt)*
argLst ::= assignExpr (COMMA assignExpr)*
enumItemLst ::= enumItem (COMMA enumItem)*
enumItem ::= TYPE_IDENTIFIER (ASSIGN INT_LIT)?
field ::= dataType IDENTIFIER (ASSIGN assignExpr)?
signature ::= specifierLst? (F LESS dataType GREATER | P) IDENTIFIER (LESS typeLst GREATER)? LPAREN typeLst? RPAREN SEMICOLON
stmt ::= (declStmt | assignExpr | returnStmt | breakStmt | continueStmt) SEMICOLON
declStmt ::= dataType IDENTIFIER (ASSIGN assignExpr)?
specifierLst ::= specifier+
specifier ::= CONST | SIGNED | UNSIGNED | INLINE | PUBLIC | HEAP
modAttr ::= MOD_ATTR_PREAMBLE LBRACKET attrLst RBRACKET
fctAttr ::= FCT_ATTR_PREAMBLE LBRACKET attrLst RBRACKET
attrLst ::= attr (COMMA attr)*
attr ::= IDENTIFIER (DOT IDENTIFIER)* ASSIGN constant
importStmt ::= IMPORT STRING_LIT (AS IDENTIFIER)? SEMICOLON
returnStmt ::= RETURN assignExpr?
breakStmt ::= BREAK INT_LIT?
continueStmt ::= CONTINUE INT_LIT?
assertStmt ::= ASSERT assignExpr SEMICOLON

// Builtin functions
builtinCall ::= printfCall | sizeOfCall | alignOfCall | lenCall
printfCall ::= PRINTF LPAREN STRING_LIT (COMMA assignExpr)* RPAREN
sizeOfCall ::= SIZEOF LPAREN (assignExpr | TYPE dataType) RPAREN
alignOfCall ::= ALIGNOF LPAREN (assignExpr | TYPE dataType) RPAREN
lenCall ::= LEN LPAREN assignExpr RPAREN

// Expression loop
assignExpr ::= prefixUnaryExpr assignOp assignExpr | ternaryExpr
ternaryExpr ::= logicalOrExpr (QUESTION_MARK logicalOrExpr? COLON logicalOrExpr)?
logicalOrExpr ::= logicalAndExpr (LOGICAL_OR logicalAndExpr)*
logicalAndExpr ::= bitwiseOrExpr (LOGICAL_AND bitwiseOrExpr)*
bitwiseOrExpr ::= bitwiseXorExpr (BITWISE_OR bitwiseXorExpr)*
bitwiseXorExpr ::= bitwiseAndExpr (BITWISE_XOR bitwiseAndExpr)*
bitwiseAndExpr ::= equalityExpr (BITWISE_AND equalityExpr)*
equalityExpr ::= relationalExpr ((EQUAL | NOT_EQUAL) relationalExpr)?
relationalExpr ::= shiftExpr ((LESS | GREATER | LESS_EQUAL | GREATER_EQUAL) shiftExpr)?
shiftExpr ::= additiveExpr ((LESS LESS | GREATER GREATER) additiveExpr)?
additiveExpr ::= multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
multiplicativeExpr ::= castExpr ((MUL | DIV | REM) castExpr)*
castExpr ::= LPAREN dataType RPAREN prefixUnaryExpr | prefixUnaryExpr
prefixUnaryExpr ::= postfixUnaryExpr | (MINUS | PLUS_PLUS | MINUS_MINUS | NOT | BITWISE_NOT | MUL | BITWISE_AND) prefixUnaryExpr
postfixUnaryExpr ::= atomicExpr (LBRACKET assignExpr RBRACKET | DOT postfixUnaryExpr | PLUS_PLUS | MINUS_MINUS | SCOPE_ACCESS postfixUnaryExpr)*
atomicExpr ::= value | (identifierExpr SCOPE_ACCESS)* identifierExpr | builtinCall | LPAREN assignExpr RPAREN {methods=[getIdentifier]}

// Values
value ::= constant | functionCall | arrayInitialization | structInstantiation | lambdaFunc | lambdaProc | lambdaExpr | NIL LESS dataType GREATER
constant ::= DOUBLE_LIT | INT_LIT | SHORT_LIT | LONG_LIT | CHAR_LIT | STRING_LIT | TRUE | FALSE
functionCall ::= (IDENTIFIER SCOPE_ACCESS)* (IDENTIFIER DOT)* identifierExpr (LESS typeLst GREATER)? LPAREN argLst? RPAREN
arrayInitialization ::= LBRACKET argLst? RBRACKET
structInstantiation ::= (IDENTIFIER SCOPE_ACCESS)* TYPE_IDENTIFIER (LESS typeLst GREATER)? LBRACE argLst? RBRACE
lambdaFunc ::= F LESS dataType GREATER LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
lambdaProc ::= P LPAREN paramLst? RPAREN LBRACE stmtLst RBRACE
lambdaExpr ::= LPAREN paramLst? RPAREN ARROW assignExpr

// Types
dataType ::= specifierLst? baseDataType (MUL | BITWISE_AND | LBRACKET (INT_LIT | TYPE_IDENTIFIER)? RBRACKET)*
baseDataType ::= TYPE_DOUBLE | TYPE_INT | TYPE_SHORT | TYPE_LONG | TYPE_BYTE | TYPE_CHAR | TYPE_STRING | TYPE_BOOL | TYPE_DYN | customDataType | functionDataType
customDataType ::= (IDENTIFIER SCOPE_ACCESS)* TYPE_IDENTIFIER (LESS typeLst GREATER)?
functionDataType ::= (P | F LESS dataType GREATER) LPAREN typeLst? RPAREN

// Shorthands
assignOp ::= ASSIGN | PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL | REM_EQUAL | SHL_EQUAL | SHR_EQUAL | AND_EQUAL | OR_EQUAL | XOR_EQUAL
overloadableOp ::= PLUS | MINUS | MUL | DIV | EQUAL | NOT_EQUAL | LESS LESS | GREATER GREATER | PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL | PLUS_PLUS | MINUS_MINUS;

identifierExpr ::= IDENTIFIER | TYPE_IDENTIFIER {
    mixin="com.spicelang.intellij.spice.psi.impl.SpiceNamedElementImpl"
    implements="com.spicelang.intellij.spice.psi.SpiceNamedElement"
    methods=[getIdentifier getName setName getNameIdentifier]
}